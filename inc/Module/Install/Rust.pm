#line 1
package Module::Install::Rust;

use 5.006;
use strict;
use warnings;

use Module::Install::Base;
use TOML 0.97 ();
use Config ();

our @ISA = qw( Module::Install::Base );

#line 21

our $VERSION = '0.04';


#line 53

sub rust_requires {
    my ($self, $name, $spec) = @_;
    $self->{rust_requires}{$name} = $spec;
}

#line 67

sub rust_feature {
    my ($self, $name, $spec) = @_;
    die "Feature $name is already defined" if $self->{rust_features}{$name};
    $self->{rust_features}{$name} = $spec;
}

#line 82

sub rust_profile {
    my ($self, $name, $spec) = @_;
    die "Profile $name is already configured" if $self->{rust_profile}{$name};

    $self->{rust_profile}{$name} = $spec;
}

#line 97

sub rust_use_perl_xs {
    my ($self, $spec) = @_;

    $spec //= { version => "0" };

    $self->rust_requires("perl-xs", $spec);
    $self->rust_clean_on_rebuild("perl-sys");
}

#line 117

sub rust_clean_on_rebuild {
    my ($self, @args) = @_;

    my $crates = $self->{cargo_clean} //= [];
    push @$crates, @args;
}

#line 132

sub rust_write {
    my $self = shift;

    $self->_rust_write_cargo;
    $self->_rust_setup_makefile;
}

sub _rust_crate_name {
    lc shift->name
}

sub _rust_target_name {
    shift->_rust_crate_name =~ s/-/_/gr
}

sub _rust_write_cargo {
    my $self = shift;

    my $crate_spec = {
        package => {
            name => $self->_rust_crate_name,
            description => $self->abstract,
            version => "1.0.0", # FIXME
        },

        lib => {
            "crate-type" => [ "cdylib" ],
        },
    };

    $crate_spec->{dependencies} = $self->{rust_requires}
        if $self->{rust_requires};

    $crate_spec->{features} = $self->{rust_features}
        if $self->{rust_features};

    $crate_spec->{profile} = $self->{rust_profile}
        if $self->{rust_profile};

    open my $f, ">", "Cargo.toml" or die $!;
    $f->print("# This file is autogenerated\n\n");
    $f->print(TOML::to_toml($crate_spec));
    close $f or die $!;
}

sub _rust_setup_makefile {
    my $self = shift;
    my $class = ref $self;

    # FIXME: don't assume libraries have "lib" prefix
    my $libname = "lib" . $self->_rust_target_name;

    my $rustc_opts = "";
    my $postproc;
    if ($^O eq "darwin") {
        # Linker flag to allow bundle to use symbols from the parent process.
        $rustc_opts = "-C link-args='-undefined dynamic_lookup'";

        # On darwin, Perl uses special darwin-specific format for loadable
        # modules. Normally it is produced by passing "-bundle" flag to the
        # linker, but Rust as of 1.12 does not support that.
        #
        # "-C link-args=-bundle" doesn't work, because then "-bundle" conflicts
        # with "-dylib" option used by rustc.
        #
        # However, it seems possible to produce correct ".bundle" file by
        # running linker with correct options on the shared library that was
        # created by rustc.
        $postproc = <<MAKE;
	\$(LD) \$(LDDLFLAGS) -o \$@ \$<
MAKE
    } else {
        $postproc = <<MAKE;
	\$(CP) \$< \$@
MAKE
    }



    $self->postamble(<<MAKE);
# --- $class section:

INST_RUSTDYLIB = \$(INST_ARCHAUTODIR)/\$(DLBASE).\$(DLEXT)
RUST_TARGETDIR = target/release
RUST_DYLIB = \$(RUST_TARGETDIR)/$libname.\$(SO)
CARGO = cargo
CARGO_OPTS = --release
RUSTC_OPTS = $rustc_opts

dynamic :: \$(INST_RUSTDYLIB)

MAKE

    if ($self->{cargo_clean}) {
        my @opts = map qq{-p "$_"}, @{$self->{cargo_clean}};

        $self->postamble(<<MAKE);
\$(RUST_DYLIB) ::
	test \$(FIRST_MAKEFILE) -ot \$@ || \$(CARGO) clean \$(CARGO_OPTS) @opts

MAKE
    }

    $self->postamble(<<MAKE);
\$(RUST_DYLIB) ::
	PERL=\$(FULLPERL) \$(CARGO) rustc \$(CARGO_OPTS) -- \$(RUSTC_OPTS)

\$(INST_RUSTDYLIB): \$(RUST_DYLIB)
$postproc

clean ::
	\$(CARGO) clean
	\$(RM) Cargo.toml Cargo.lock
MAKE
}

#line 266

1;
